运行时抽象
	一个软件架构是一个软件系统在其操作的某个阶段的运行时(run-time)元素的抽象。
	一个系统可能有很多层抽象和很多个操作阶段组成，每个抽象和操作阶段都有自己的软件架构。

	多层抽象：
	软件架构的核心是抽象原则：通过封装来隐藏系统的一些细节，从而更好地识别和支持系统的属性
	一个复杂的系统包含多层的抽象，每一层抽象都有自己的架构。
	架构代表了某个层次上系统行为的抽象，架构的元素被描述为提供给同层的其他元素的抽象接口。
	元素可能包含另一个架构，定义子元素的系统。

	多个操作阶段：
	每个操作阶段都有自己的架构
	系统的一个整体描述必须既能够描述各个阶段的系统架构的行为，也能够描述在各个阶段之间的架构的迁移。

元素：
	一个软件架构由一些架构元素（组件、连接器和数据）的配置来定义，这些元素之间的关系受到约束，以获得想要得到的一组架构属性。

	软件架构呗定义为一组架构元素，这些元素具有通过一组基本原理来描述的特殊形式。
	架构元素包括处理、数据、连接元素。
	形式则由元素的属性和元素之间的关系（即元素之上的约束）来定义。
	基本原理本身并不是架构的一部分。
	处理元素（组件）：执行数据转换的元素
	数据元素：包含被使用和被转换的信息的元素
	连接元素：将架构的不同部分结合在一起的粘合剂

组件：
	一个组件是软件指令和内部状态的一个抽象单元，通过其接口提供对于数据的转换。
	每个组件的行为是架构的一部分，能够被其他组件观察到或者看到。
	组件应该由它为其他组件提供的接口和服务来定义，而不是由它在接口之后的实现来定义。

连接器
	一个连接器是对组件之间的通讯、协调或者合作进行仲裁的一种抽象机制。
	连接器的例子包括：共享的表述、远程过程调用、消息传递协议和数据流。
	连接器不改变数据

数据
	一个数据是组件通过一个连接器接收或发送的信息元素
	数据的例子包括：字节序列、消息、编码过的参数、序列化的对象等。但是不包括哪些永久驻留或隐藏在组件中的消息。

配置
	一个配置是在系统的运行期间组件、连接器和数据之间的架构关系的结构。
	相互交互的组件和连接器的集合

属性
	软件架构的架构属性集合包括了对组件、连接器和数据的选择和排列所导致的所有属性。
	架构属性的例子包括了可以由系统获得的功能属性和非功能属性，例如：进化的相对容易程度、组件的可重用性、效率、动态扩展能力；这些呗称为品质属性。
	属性是由架构中的一组约束所导致的。
	约束往往是由在架构元素的某个方面应用软件工程原则来驱动的。
	架构设计的目标是创建一个包含一组架构属性的架构，这些架构属性形成了系统需求的一个超集。

风格
	一种架构风格是一组协作的架构约束，这些约束限制了架构元素的角色和功能，以及在任何一个遵循该风格的架构中允许存在的元素之间的关系。 
	是一种用来对架构进行分类和定义它们的公共特征的机制。
	对于不同元素类型的一种抽象和来自不同的特定架构的形式化方面。
	一种特定的架构可能是由多种架构风格组成的。同样地，能够通过将多种基本风格组合成单个的协作风格来形成一种混合风格。

模式和模式语言
	一种设计模式被定义为一种重要的和重复出现的系统构造。
	一种模式语言是一个模式的系统，以一种对这些模式的应用加以指导的结构来组织。

视图
	处理视图：侧重于流过组件的数据流，以及组件之间连接的那些与数据相关的方面。
	数据视图：侧重于处理的流程，而不是连接器
	连接视图：侧重于组件之间的关系和通信的状态。


基于网络的应用的架构
基于网络 vs. 分布式
基于网络的架构与软件架构的主要区别通常是：组件之间的通讯仅限于消息传递或者消息传递的等价物。
在某些情况下，希望用户知道一个需要网络请求的动作和一个在他们的本地系统就能满足的动作之间的差别，尤其是当使用网络意味着额外的处理成本的时候。

应用软件 vs. 网络软件
应用软件代表的是一个系统的“理解业务”(business-aware)的那部分功能。

评估应用软件架构的设计
第一个层面的评估由应用的功能需求来设定。
比较不同的架构：
	识别出每个架构的约束，评估每个约束所导致的一组属性，，并将设计累积的属性与那些应用要求的属性进行比较。

关键关注点的架构属性：
性能
	一个基于网络的应用的性能首先取决于应用的需求，然后是所选择的交互风格，然后是实现的架构，最后是每个组件的实现。
	网络性能
		用来描述通信的某些属性。
		吞吐量：信息（既包括应用的数据也包括通信负载）在组件之间转移的速率。
		负载：可分为初始设置的负载和每次交互的负载。
		带宽：在一个特定的网络连接之上可用的最大吞吐量。
		可用带宽：实际可用的那部分带宽
	用户可觉察的性能
		延迟：指从触发初次请求到得到第一个响应指示之间持续的时间。
		完成时间：完成一个应用动作所花费的时间。
		动作的完成时间和它的延迟之间的区别在于，延迟代表一种应用增量处理正在接收的数据的程度。
		对延迟进行优化的设计常常会产生延长完成时间的副作用，反之亦然。
	网络效率
		对于一个基于网络的应用，最高效的架构风格是那些在可能的情况下，能够有效地将对于网络的使用减到最少的架构风格。

	可伸缩性
		可伸缩性能够通过以下方法来改善：简化组件、将服务分布到很多组件、以及作为监视的结果对交互和配置进行控制。
		可伸缩性还受到以下几个因素的影响：交互的频率、组件负担的分布是否平均或出现峰值、交互是不需要担保送达还是最需要尽量送达、一个请求是否包括了同步或异步的处理、环境是受控的还是无法控制的。

	简单性：
		对组件之间的功能分配应用分离关注点原则

	可修改性
		可进化性
			一个组件实现能够被改变而不会对其他组件产生负面影响的程度。
		可扩展性
			将功能添加到一个系统中的能力
			动态可扩展意味着功能能够被添加到一个已部署的系统中，而不会影响到系统的其他部分。
		可定制性
			临时性地规定一个架构元素的行为的能力，然后该元素能提供一种非常规的服务。
		可配置性
			部署后对于组件，或者对于组件配置的修改，组件能够使用新的服务或者新的数据元素类型。
		可重用性
	可见性
		风格能够通过限制必须使用通用性的接口，或者提供访问监视功能的方法，来影响基于网络的应用中交互的可见性。
		一个组件对于其他两个组件之间的交互进行监视或仲裁的能力。
		可见性能够通过以下方式改善性能：交互的共享缓存、通过分层服务提供可伸缩性、荣国反射式监视提供可靠性、允许中间组件对交互做检查提供安全性
	可可移植性
	可靠性
		一个架构容易受到系统层面故障影响的程度。通过以下方法提高可靠性：避免单点故障、增加冗余、允许监视、以及用可恢复的动作来缩小故障的范围。

基于网络的架构风格
	应当基于这些架构风格所导致的架构属性来对架构风格进行分类






REST架构的元素
聚焦于：组件的角色，组件之间的交互之上的约束、组件对重要数据元素的解释
数据元素
	数据元素的性质和状态
	1、在数据的所在地对数据进行呈现，并向接受者发送一个固定格式的图像
	2、将数据和呈现引擎封装起来并将两者一起发送给接收者
	3、发送原始数据和一些描述数据类型的元数据，这样接收者就能选择他们自己的呈现引擎
	




